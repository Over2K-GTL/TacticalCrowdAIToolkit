// Copyright 2025-2026 Over2K. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "TCATHeightMapModule.h"
#include "Core/TCATTypes.h"
#include "GameFramework/Volume.h"
#include "Simulation/TCATCompositeRecipe.h"
#include "Simulation/TCATGridResource.h"
#include "VisualLogger/VisualLoggerTypes.h"
#include "TCATInfluenceVolume.generated.h"

class UTCATInfluenceComponent;
class UTextureRenderTarget2D;
struct FTransientSourceWrapper;
class FTextureRenderTargetResource;
class UTCATDebugGridComponent;

UENUM(BlueprintType)
enum class ETCATDebugDrawMode : uint8
{
    /** Disables all debug drawing for this volume. */
    None        UMETA(DisplayName = "None"),
    
    /** Draws only maps marked as Visible in each map's Debug Settings. (Default) */
    VisibleOnly UMETA(DisplayName = "Visible Maps Only"),
    
    /** Draws every map regardless of per-map visibility flags. */
    All         UMETA(DisplayName = "All Maps"),
};

USTRUCT(BlueprintType)
struct FTCATRaymarchingSettings
{
    GENERATED_BODY()
    /**
        * Adaptive precision step size for line-of-sight / raymarch checks.
        *
        * This is the minimum distance traveled per step. If the target is too far and the ray
        * would exceed LineOfSightMaxSteps, the effective step size increases to ensure the ray
        * reaches the target within the fixed step budget.
        *
        * Smaller values = higher precision (more samples per distance).
        * Larger values  = lower precision (fewer samples per distance).
    */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="TCAT", meta=(ClampMin="1.0", UIMin="1.0"))
    float LineOfSightStepSize = 50.0f;

    /**
    * Hard cap on the number of samples taken per line-of-sight / raymarch query.
    * This guarantees an upper bound on the GPU/CPU cost per check, regardless of distance.
    */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="TCAT", meta=(ClampMin="1", UIMin="1"))
    int32 LineOfSightMaxSteps = 32;
};

USTRUCT(BlueprintType, meta = (DisplayName = "Base Map Config"))
struct FTCATBaseLayerConfig
{
    GENERATED_BODY()
    /**
      * Tag for a raw (base) map produced by Influence Components (e.g., "Enemy", "Ally").
      * This tag is also used as the key for runtime maps and resources.
    */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Config", meta = (GetOptions = "GetAllTagOptions"), meta = (DisplayName = "Base Map Tag"))
    FName BaseLayerTag;

    /**
      * Bitmask that enables 3D projection / visibility rules for this map.
      *
      * Flags (ETCATProjectionFlag):
      * - MaxInfluenceHeight:
      *   Applies a vertical cutoff using Source.MaxInfluenceZ (computed per source as:
      *   OwnerBoundingBoxTop.Z + InfluenceZLimitOffset). Cells above MaxInfluenceZ are not affected.
      *
      * - LineOfSight:
      *   Applies an occlusion check between the source "eye level" and the target cell.
      *   The eye level is offset by LineOfSightOffset (see FTCATInfluenceSource / UTCATInfluenceComponent).
      *   Raymarch sampling budget is configured via RayMarchSettings.
      */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Config", meta = (Bitmask, BitmaskEnum = "/Script/TCAT.ETCATProjectionFlag"))
    int32 ProjectionMask = 0;

    /** Advanced raymarch / line-of-sight settings used by 3D projection features. */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, AdvancedDisplay, Category = "Config", meta=(DisplayName="Advanced"))
    FTCATRaymarchingSettings RayMarchSettings;
};

USTRUCT(BlueprintType)
struct FTCATCompositeLayerConfig
{
    GENERATED_BODY()

    /**
    * Tag for a composite (derived) map generated by applying CompositeLogic(DataAsset) operations over BASE MAPS
    */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Composition", meta=(GetOptions="GetCompositeTagOptions"), meta = (DisplayName = "Composite Map Tag"))
    FName CompositeLayerTag;

    /**
       * Data Asset describing how to build this composite map (list of operations).
       * If unset, this composite map is skipped.
    */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Composition")
    TObjectPtr<UTCATCompositeRecipe> CompositeRecipe;
};

UCLASS(
    HideCategories = (Collision, HLOD, Physics, Networking, Replication, Input, Cooking, LevelInstance, DataLayers, WorldPartition, LOD, Streaming),
    meta = (PrioritizeCategories = "Transform TCAT BrushSettings")
)

/**
 * TCAT Influence Volume
 *
 * This actor defines the 2D influence grid domain (X/Y) and optionally a baked height grid (Z) used by TCAT.
 *
 * Placement / Level Setup Notes (IMPORTANT)
 * - Place this volume so it fully covers the playable area in X/Y.
 * - Keep the volume "grounded": its bottom should intersect or sit slightly below the terrain / floor.
 *   (Think of it like placing a NavMeshBoundsVolume: you generally don't want it floating high above the ground.)
 * - TCAT uses a baked height grid for projection and some queries. If the volume is floating far above the level,
 *   height sampling and line-of-sight / projection features can behave unexpectedly.
 * - After resizing the volume or changing CellSize, run "Bake Resolution" to rebuild GridResolution and the height grid.
 *
 * Notes
 * - This volume is NOT the NavMesh itself and does not require NavMesh to exist, but many gameplay setups place both
 *   volumes over the same grounded region for consistent behavior.
 */
class TCAT_API ATCATInfluenceVolume : public AVolume
{
    GENERATED_BODY()

    friend class UTCATSubsystem;
    friend struct FTCATHeightMapModule;
    friend class FTCATEditorModule;

public:
    ATCATInfluenceVolume();
    
public:
    /** Returns World-space bounding box of this volume, cached from brush component bounds. */
    FORCEINLINE const FBox& GetCachedBounds() const { return CachedBounds; }

    /** Returns the size of a single grid cell. */
    FORCEINLINE float GetCellSize() const { return CellSize; }

    /** Number of columns (X) in the grid. */
    FORCEINLINE int32 GetColumns() const { return GridResolution.X; }
    /** Number of rows (Y) in the grid. */
    FORCEINLINE int32 GetRows() const { return GridResolution.Y; }
    
    /** Retrieves an influence or height value from a specific map at grid coordinates.
     * @param MapTag The tag of the map (e.g., "Enemy", "Ally", or "GlobalHeight").
     */
    UFUNCTION(BlueprintCallable, Category = "TCAT")
    float GetInfluenceFromGrid(FName MapTag, int32 InX, int32 InY) const;

    /**
     * Returns the world-space origin used for grid conversions.
     * X/Y uses the volume bounds minimum corner.
     * Z uses the volume bounds center Z.
     * NOTE: Height drawing uses the height grid (if available) and can override Z per cell.
     */
    UFUNCTION(BlueprintCallable, Category = "TCAT")
    FVector GetGridOrigin() const;

    /**
    * Returns the height value stored in the baked height grid at a cell index.
    *
    * IMPORTANT: This function assumes CellIndex is valid for the current GridResolution.
    * It does not validate bounds before indexing the array.
    */
    UFUNCTION(BlueprintCallable, Category = "TCAT")
    float GetGridHeightIndex(FIntPoint CellIndex) const;

    /**
    * Converts a world position to a grid cell and returns the baked height value for that cell.
    */
    UFUNCTION(BlueprintCallable, Category = "TCAT")
    float GetGridHeightWorldPos(FVector WorldPos) const;
    
    /**
    * Returns the projection bitmask for a base layer tag in O(1).
    * Returns 0 if the layer is not configured.
    */
    int32 GetProjectionMask(FName LayerTag) const;

    /**
    * Returns the runtime grid resource for a layer tag (base or composite).
    * @return nullptr if the layer resource does not exist.
    */
    const FTCATGridResource* GetLayerResource(FName LayerTag) const;
    void GetLayerMinMax(FName MapTag, float& OutMin, float& OutMax); 

    /**
     * True when GPU refresh is enabled AND position prediction is enabled.
     * Additional conditions may exist in calling code, but this is the local gate used here.
     */
    FORCEINLINE bool IsPossiblePrediction() const { return bRefreshWithGPU && bEnablePositionPrediction; }

    /**
     * Scans overlapping Influence Components within this volume bounds and adds any missing
     * Base Map Config entries for newly discovered tags.
     */
    UFUNCTION(CallInEditor, Category = "TCAT", meta=(DisplayName="Add Missing Maps"))
    void AddMissingLayers();
    
#if WITH_EDITOR
    virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif

protected:
    virtual void BeginPlay() override;
    virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
    virtual void BeginDestroy() override;

    void UpdateVolumeInfos();
    
    /** Gather All Component, and Categorize by Tag*/
    void RefreshSources();

    /** Allocate RenderTargets and related resources based on tags */
    void InitializeResources();

    void UpdateGridSize();

    void UpdateMemoryStats();
    
    void RebuildRuntimeMaps();
    
    /** Ensures that a base layer exists for the given tag, creating one if necessary. */
    void BatchEnsureBaseLayers(const TSet<FName>& NewTags);

//~=============================================================================
// Self Influence Build
//~=============================================================================
public:
    /** Returns 1.0 / Range for the specified layer. Returns 0 if range is invalid. */
    float GetLayerScaleFactor(FName LayerTag) const;

    /** Retrieves the baked recipe map for a specific component's source tag. */
    const TMap<FName, FTCATSelfInfluenceRecipe>* GetBakedRecipesForSource(FName SourceTag) const;
    
protected:
    /** * [Runtime Cache] 
         * Key: Source Layer Tag (e.g., "Ally")
         * Value: Map of Target Layer -> Recipe 
         * (e.g., "Ally" -> { "TotalDanger" : Recipe, "Ally" : Recipe })
         */
    TMap<FName, TMap<FName, FTCATSelfInfluenceRecipe>> CachedInfluenceRecipes;
    
    /** Builds the dependency graph and calculates reverse recipes. */
    void RebuildInfluenceRecipes();
    
//~=============================================================================
// Configuration
//~=============================================================================
protected:
    /**
     * Grid cell size in Unreal units.
     *
     * WARNING: If the computed resolution exceeds the MaxMapResolution(Check Project Setting > Plugin TCAT Setting),
     * this volume will automatically increase CellSize to clamp the resolution.
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "TCAT", meta = (ClampMin = "0.01", UIMin = "0.01"))
    float CellSize = TCATGlobalSettings::DEFAULT_CELL_SIZE;

    /** Current grid resolution (Columns x Rows) derived from bounds and CellSize. */
    UPROPERTY(VisibleInstanceOnly, Category= "TCAT", meta=(DisplayName="Grid Resolution"))
    FString GridResolutionDisplay;

    UPROPERTY()
    FIntPoint GridResolution;
    
    /**
    * Per-base-map configuration (raw maps coming from Influence Components).
    * Each entry defines tag-specific projection rules and debug settings.
    */
    UPROPERTY(EditAnywhere, Category="TCAT", meta=(TitleProperty="BaseLayerTag", DisplayName="Base Map Configs"))
    TArray<FTCATBaseLayerConfig> BaseLayerConfigs;

    /** Runtime Cache of TArray<FTCATBaseLayerConfig> BaseMapConfigs, O(1) Search */
    UPROPERTY(Transient)
    TMap<FName, FTCATBaseLayerConfig> CachedBaseLayerMap;
    
    /**
      * Composite map definitions.
      * These maps are derived from other base maps using a CompositeRecipe(Data Asset) operation list.
      */
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="TCAT", meta=(TitleProperty="CompositeLayerTag", DisplayName="Composite Map Configs"))
    TArray<FTCATCompositeLayerConfig> CompositeLayers;
    
//~=============================================================================
// Debug Configuration
//~=============================================================================
protected:
    /** Debug draw mode for influence maps in the 3D viewport. */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="TCAT|DebugSettings")
    ETCATDebugDrawMode DrawInfluence = ETCATDebugDrawMode::VisibleOnly;
    
    /**
    * Height map module configuration and debug draw options.
    * The actual height grid is stored in HeightResource and is (re)baked via BakeHeightMap().
    */
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "TCAT|DebugSettings", meta=(ShowOnlyInnerProperties))
    FTCATHeightMapModule HeightMap;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="TCAT|DebugSettings")
    bool bShowInfluenceValues = true;

    /** Color for debug text labels displaying cell values. */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="TCAT|DebugSettings", meta = (EditCondition = "bShowInfluenceValues", EditConditionHides))
    FLinearColor DebugTextColor = FLinearColor::White;
    
    /** Debug settings for all layers (base and composite). Auto-synced with map configs. */
    UPROPERTY(EditAnywhere, Category="TCAT|DebugSettings", meta=(TitleProperty="MapTag"), meta=(DisplayName="Map Debug Settings"))
    TArray<FTCATLayerDebugSettings> LayerDebugSettings;
    
    /**
     * Recomputes GridResolution from current CellSize and volume bounds, then bakes the height grid.
     *
     * TIP: Run this after:
     * - Moving / resizing the volume
     * - Changing CellSize
     * - Adjusting terrain/level geometry under the volume
     *
     * For best results, keep the volume grounded (bottom intersects the terrain/floor), similar to typical NavMesh volumes.
     */
    UFUNCTION(CallInEditor, Category = "TCAT", meta=(DisplayName="Bake Resolution"))
    void BakeHeightMap();
    
private:
    // Helper to find debug config (now we don't need a cached map, just lookup or cache if needed)
    // For simplicity, we can rebuild a transient map for O(1) access during Draw
    UPROPERTY(Transient)
    TMap<FName, FTCATLayerDebugSettings> CachedDebugSettingsMap;

    UPROPERTY(Transient)
    bool bIsHeightBaked = false;

//~=============================================================================
// Performance Configuration
//~=============================================================================
protected:
    /** If true, when there is little performance difference between updating the map on the GPU or CPU,
    map updates are performed on the CPU(bRefreshWithGPU = false) because CPU Updating avoids the risk of prediction failure.
    When updating on the GPU performs better than on the CPU, map updates are performed on the GPU(bRefreshWithGPU = true). 
    "bRefreshWithGPU" is modified by the TCATSubsystem.
    To modify related detailed settings, go to Project Settings > Plugins > TCAT Global Settings > Advanced > Adaptive GPU/CPU update mode switching.*/
	UPROPERTY(EditAnywhere, Category = "TCAT|Performance")
	bool bAdaptivelySwitchRefreshMode = true;

    /** If true, the influence map is generated using Compute Shaders on the GPU. */
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="TCAT|Performance")
    bool bRefreshWithGPU = true;;
    
    /** If true, enables position extrapolation for influence calculations. 
    Because the results of the influence map update arrive a few frames later, this option predicts the position of the InfluenceComponent a few frames ahead and uses that position for the influence map update. */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "TCAT|Performance", meta = (EditCondition = "bRefreshWithGPU"))
    bool bEnablePositionPrediction = true;
        
	/** To handle situations where the frame rate suddenly increases and then decreases, 
    if the delta time increases by more than 켼edictionCorrectionThresholdtimes compared to the previous delta time, 
    the PredictionTime is not immediately increased. Instead, the previously used PredictionTime is used.
    For more detailed information, refer to the code that uses the variable. */
    UPROPERTY(EditAnywhere, Category = "TCAT", AdvancedDisplay)
	float PredictionCorrectionThreshold = 2.0f;

    /** The degree to which acceleration is reflected in the prediction */
    UPROPERTY(EditAnywhere, Category = "TCAT", AdvancedDisplay)
    float AccelerationPredictionFactor = 1.0f;
    
    /** If true, logs per-map grid state into Visual Logger (async/GPU related telemetry). */
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="TCAT|Performance", meta=(EditCondition="bRefreshWithGPU"))
    bool bLogAsyncFrame = false;

    /** If true, forces single-threaded update of the influence map when bRefreshWithGPU is false, useful for debugging. */
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "TCAT", AdvancedDisplay, meta=(EditCondition="!bRefreshWithGPU"))
    bool bForceCPUSingleThreadUpdate = false;
private:
    /** TCATSettings to Editor UI Functions */
    
    UFUNCTION()
    TArray<FString> GetAllTagOptions() const;
    
    UFUNCTION()
    TArray<FString> GetBaseTagOptions() const;

    UFUNCTION()
    TArray<FString> GetCompositeTagOptions() const;

//~=============================================================================
// Resources
//~=============================================================================
public:
    /** Returns the RenderTarget holding the baked Global Height map (may be null if not initialized). */
    UTextureRenderTarget2D* GetHeightRenderTarget() const;

    /** Returns the RenderTargetResource for the Baked Global Height map. */
    FTextureRenderTargetResource* GetHeightRenderTargetTexture() const;
    
private:
    class UTCATSubsystem* GetTCATSubsystem() const;
        
    /** Height map */
    UPROPERTY(VisibleInstanceOnly, Transient, Category = "TCAT", AdvancedDisplay)
    FTCATHeightMapResource HeightResource;

    /** actual Influence Resources per MapTag */
    UPROPERTY(VisibleInstanceOnly, Category = "TCAT", AdvancedDisplay, meta = (DisplayName = "Influence Resources"))
    TMap<FName, FTCATGridResource> InfluenceLayers;

    /** Source Data per Tag (Updated Every Frame) */
    TMap<FName, TArray<FTCATInfluenceSource>> LayerSourcesMap;

	/** Source Data with Owner Component per Tag (Updated Every Frame) */
    TMap<FName, TArray<FTCATInfluenceSourceWithOwner>> LayerSourcesWithOwners;

	/** Position Prediction Time Cache per Layer Tag */
    TMap<FName, FTCATPredictionInfo> TagToPredictionInfo;
    
    FBox CachedBounds;

    float LastDeltaSeconds = 0.0;
    
//~=============================================================================
// Debug
//~=============================================================================
private:
    void DebugDrawGrid();

    /** Captures and logs the current state for the Visual Logger. */
    void VLogInfluenceVolume() const;

#if WITH_EDITORONLY_DATA
    /** Debug visualization component using custom scene proxy for efficient batched rendering. */
    UPROPERTY(VisibleAnywhere, Transient, Category = "Debug")
    TObjectPtr<UTCATDebugGridComponent> DebugGridComponent;
#endif
};